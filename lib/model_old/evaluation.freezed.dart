// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'evaluation.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Evaluation {
  int? get wc => throw _privateConstructorUsedError;
  int? get kitchen => throw _privateConstructorUsedError;
  int? get store => throw _privateConstructorUsedError;
  int? get location => throw _privateConstructorUsedError;
  int? get landscape => throw _privateConstructorUsedError;
  int? get congestion => throw _privateConstructorUsedError;
  int? get site => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EvaluationCopyWith<Evaluation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EvaluationCopyWith<$Res> {
  factory $EvaluationCopyWith(
          Evaluation value, $Res Function(Evaluation) then) =
      _$EvaluationCopyWithImpl<$Res, Evaluation>;
  @useResult
  $Res call(
      {int? wc,
      int? kitchen,
      int? store,
      int? location,
      int? landscape,
      int? congestion,
      int? site});
}

/// @nodoc
class _$EvaluationCopyWithImpl<$Res, $Val extends Evaluation>
    implements $EvaluationCopyWith<$Res> {
  _$EvaluationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wc = freezed,
    Object? kitchen = freezed,
    Object? store = freezed,
    Object? location = freezed,
    Object? landscape = freezed,
    Object? congestion = freezed,
    Object? site = freezed,
  }) {
    return _then(_value.copyWith(
      wc: freezed == wc
          ? _value.wc
          : wc // ignore: cast_nullable_to_non_nullable
              as int?,
      kitchen: freezed == kitchen
          ? _value.kitchen
          : kitchen // ignore: cast_nullable_to_non_nullable
              as int?,
      store: freezed == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as int?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as int?,
      landscape: freezed == landscape
          ? _value.landscape
          : landscape // ignore: cast_nullable_to_non_nullable
              as int?,
      congestion: freezed == congestion
          ? _value.congestion
          : congestion // ignore: cast_nullable_to_non_nullable
              as int?,
      site: freezed == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EvaluationImplCopyWith<$Res>
    implements $EvaluationCopyWith<$Res> {
  factory _$$EvaluationImplCopyWith(
          _$EvaluationImpl value, $Res Function(_$EvaluationImpl) then) =
      __$$EvaluationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? wc,
      int? kitchen,
      int? store,
      int? location,
      int? landscape,
      int? congestion,
      int? site});
}

/// @nodoc
class __$$EvaluationImplCopyWithImpl<$Res>
    extends _$EvaluationCopyWithImpl<$Res, _$EvaluationImpl>
    implements _$$EvaluationImplCopyWith<$Res> {
  __$$EvaluationImplCopyWithImpl(
      _$EvaluationImpl _value, $Res Function(_$EvaluationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wc = freezed,
    Object? kitchen = freezed,
    Object? store = freezed,
    Object? location = freezed,
    Object? landscape = freezed,
    Object? congestion = freezed,
    Object? site = freezed,
  }) {
    return _then(_$EvaluationImpl(
      wc: freezed == wc
          ? _value.wc
          : wc // ignore: cast_nullable_to_non_nullable
              as int?,
      kitchen: freezed == kitchen
          ? _value.kitchen
          : kitchen // ignore: cast_nullable_to_non_nullable
              as int?,
      store: freezed == store
          ? _value.store
          : store // ignore: cast_nullable_to_non_nullable
              as int?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as int?,
      landscape: freezed == landscape
          ? _value.landscape
          : landscape // ignore: cast_nullable_to_non_nullable
              as int?,
      congestion: freezed == congestion
          ? _value.congestion
          : congestion // ignore: cast_nullable_to_non_nullable
              as int?,
      site: freezed == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$EvaluationImpl extends _Evaluation {
  const _$EvaluationImpl(
      {this.wc,
      this.kitchen,
      this.store,
      this.location,
      this.landscape,
      this.congestion,
      this.site})
      : super._();

  @override
  final int? wc;
  @override
  final int? kitchen;
  @override
  final int? store;
  @override
  final int? location;
  @override
  final int? landscape;
  @override
  final int? congestion;
  @override
  final int? site;

  @override
  String toString() {
    return 'Evaluation(wc: $wc, kitchen: $kitchen, store: $store, location: $location, landscape: $landscape, congestion: $congestion, site: $site)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EvaluationImpl &&
            (identical(other.wc, wc) || other.wc == wc) &&
            (identical(other.kitchen, kitchen) || other.kitchen == kitchen) &&
            (identical(other.store, store) || other.store == store) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.landscape, landscape) ||
                other.landscape == landscape) &&
            (identical(other.congestion, congestion) ||
                other.congestion == congestion) &&
            (identical(other.site, site) || other.site == site));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, wc, kitchen, store, location, landscape, congestion, site);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EvaluationImplCopyWith<_$EvaluationImpl> get copyWith =>
      __$$EvaluationImplCopyWithImpl<_$EvaluationImpl>(this, _$identity);
}

abstract class _Evaluation extends Evaluation {
  const factory _Evaluation(
      {final int? wc,
      final int? kitchen,
      final int? store,
      final int? location,
      final int? landscape,
      final int? congestion,
      final int? site}) = _$EvaluationImpl;
  const _Evaluation._() : super._();

  @override
  int? get wc;
  @override
  int? get kitchen;
  @override
  int? get store;
  @override
  int? get location;
  @override
  int? get landscape;
  @override
  int? get congestion;
  @override
  int? get site;
  @override
  @JsonKey(ignore: true)
  _$$EvaluationImplCopyWith<_$EvaluationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
